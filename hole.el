;; key maps;; (defconst alab-mode-key-map;;   '(;;    ((kbd "C-c C-g") . agda2-go);;    ((kbd "C-c C-r") . refine-goal);;    ((kbd "C-c C-m") . match-variable);;    );;   );; (define-minor-mode overriding-minor-mode;;   "強制的にC-tを割り当てる"             ;説明文字列;;   t                                     ;デフォルトで有効にする;;   ""                                    ;モードラインに表示しない;;   `((,(kbd "C-t") . other-window-or-sprit)));; (define-minor-mode hungry-mode;;   "Toggle Hungry mode.;; ...rest of documentation as before...";;  ;; The initial value.;;  :init-value nil;;  ;; The indicator for the mode line.;;  :lighter " Hungry";;  ;; The minor mode bindings.;;  :keymap;;  '(([C-backspace] . hungry-electric-delete);;    ([C-M-backspace];;     . (lambda ();;         (interactive);;         (hungry-electric-delete t))));;  :group 'hunger);; (define-minor-mode ocaml-alab-mode;;   "This is the OCaml mode used for Asai lab.;; \C-c\C-g: agda2-go,;; \C-c\C-r: refine-goal,;; \C-c\C-m: match-variable.";;   :init-value nil;;   :lighter " alab-mode";;   :keymap (let ((map (make-sparse-keymap)));;             (define-key map (kbd "C-c g") 'agda2-go);;             map);;   );; (add-hook 'tuareg-mode-hook 'ocaml-alab-mode);; (provide 'ocaml-alab-mode)(defun set-alab-mode-key ()  (interactive)  (mapc 'set-global-key '(			  ("\C-cg" . 'agda2-go)			  ("\C-cr" . 'refine-goal)			  ("\C-cm" . 'match-variable)			  )	))(defun set-global-key (key)  (global-set-key (car key) (car (last key))));; from annotation.el(defmacro annotation-preserve-mod-p-and-undo (&rest code)  "Run CODE preserving both the undo data and the modification bit.Modification hooks are also disabled."  (let ((modp (make-symbol "modp")))  `(let ((,modp (buffer-modified-p))         ;; Don't check if the file is being modified by some other process.         (buffer-file-name nil)         ;; Don't record those changes on the undo-log.         (buffer-undo-list t)         ;; Don't run modification hooks.         (inhibit-modification-hooks t))     (unwind-protect         (progn ,@code)       (restore-buffer-modified-p ,modp)))));; Annotation for a goal;; exit(*{ ... }*)3;; ----------------  overlay: agda2-gn num, face highlight, after-string num,;;                            modification-hooks (agda2-protect-goal-markers);; -------           text-props: category agda2-delim1;;             ----  text-props: category agda2-delim2;; Char categories for the goal(defvar agda2-open-brace "{")(defvar agda2-close-brace " }")(setplist 'agda2-delim1 `(display ,agda2-open-brace rear-nonsticky t				   agda2-delim1 t))(setplist 'agda2-delim2 `(display ,agda2-close-brace rear-nonsticky t				  agda2-delim2 t))(defun agda2-make-goal (p q r)  "Make a goal at exit(*{<p>...<q>}*)n<r>."  (annotation-preserve-mod-p-and-undo    (let ((n (buffer-substring (+ q 3) r))	  (o (make-overlay (- p 7) r nil t nil)))      (print n)      (add-text-properties (- p 7) p '(category agda2-delim1))      (add-text-properties q r '(category agda2-delim2))      (overlay-put o 'agda2-gn           n)      (overlay-put o 'face               'highlight)      (overlay-put o 'after-string       (propertize (format "%s" n) 'face 'highlight))      o )))(defun agda2-search-goal ()  (if (re-search-forward "exit(\\*{" nil t 1)    (let ((p (point)))      (if (re-search-forward "}\\*)" nil t 1)	(let ((q (- (point) 3)))	  (if (re-search-forward "[0-9]+" nil t 1)	      (let ((r (point)))		(agda2-make-goal p q r))))))))(defun agda2-go ()  (interactive)  (progn    (goto-char (point-min))    (while (agda2-search-goal)	   ; no body      )));; TODO:;; 6. set the command-key*;; 8. refine-goal with argument*;; 9. refine or match goal only when (position) is in the goal;; 10. clear all overlays when agda2-go to gensym (i.e. C-x C-l)*;; 11. compile to check errors before agda2-go (load) before refine and match goal;; 12. begin ... end;; 13. support list, if, record*;; 14. support show-goal (and its env): split-window, generate-new-buffer etc.*(defun refine-goal ()  (interactive)  (let ((filename (buffer-file-name))	(num (get-hole-number)))    (progn      (print num)      ;; save      (save-buffer)      (agda2-reset)      (call-process "/Users/YukiIshii/lab/expander/expander" nil t nil filename num "Refine")      )))(defun match-variable ()  (interactive)  (let ((word (thing-at-point 'word))	(filename (buffer-file-name))	(num (get-hole-number)))    (progn      (print num)      (save-buffer)      (agda2-reset)      (call-process "/Users/YukiIshii/lab/expander/expander" nil t nil filename num "Match" word)      (ocp-indent-buffer)      )))(defun get-hole-number ()   (goto-char (point))   (if (re-search-backward "{" nil t 1)       ;;(let ((p (point)))       (if (re-search-forward "}" nil t 1)	   ;;(let ((q (- (point) 3)))	   (if (re-search-forward "[0-9]+" nil t 1)	       (let ((r (point)))		 (buffer-substring (- r 1) r)		 )))));; erase hole;;  (add-text-properties (- p 7) p '(category agda2-delim1));;  (add-text-properties q r '(category agda2-delim2))(defun agda2-remove-hole (p q)  (progn    ;; remove text properties    ;; e.g. {hello } with text properties -> exit(*{hello }*)3 without text properties    (remove-text-properties (- p 7) p '(category agda2-delim1))    (remove-text-properties q (+ q 3) '(category agda2-delim2))    (goto-char (point))    ;; remove hole    (if (re-search-backward "exit(\\*{" nil t 1)	(let ((p (point)))	  (if (re-search-forward "}\\*)" nil t 1)	      (let ((q (- (point) 3)))		(if (re-search-forward "[0-9]+" nil t 1)		    (let ((r (point)))		      (delete-region p r)))))))    ))(defun agda2-search-hole ()  (if (re-search-backward "{" nil t 1)    (let ((p (point)))      (if (re-search-forward "}" nil t 1)	(let ((q (point)))	  ;; (if (re-search-forward "[0-9]+" nil t 1)	  ;;     (let ((r (point)))	  ;; 	(agda2-remove-hole p q r)))	  (let ((lays (overlays-in p q)))	    (delete-lays lays)	    (agda2-remove-hole p q) ;; e.g. {v } -> { }	    ))))))(defun delete-lays (lays)  (let (value)    (dolist (elt lays value)      (delete-overlay elt)))) ;; e.g. {v }3 with highlight -> {v } without highlight  (defun agda2-reset ()  ;;(interactive)  (progn    (goto-char (point))    ;; (agda2-search-hole)))    (while (agda2-search-hole)      ;; no body      )))